(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{597:function(e,n,a){"use strict";a.r(n);var s=a(15),t=Object(s.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"},[e._v("介绍")]),a("p",[e._v("Angular中操作DOM非常简单，但直接操作DOM有一个主要的缺点，它与浏览器平台紧密相关了。为了在不同的平台（platform）使用，Angular提供了以下的抽象，这些抽象以引用类型的形式存在： ElementRef, TemplateRef, ViewRef, ComponentRef 和 ViewContainerRef.")])]),a("h2",{attrs:{id:"viewchild"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#viewchild"}},[e._v("#")]),e._v(" "),a("a",{attrs:{href:"https://angular.cn/api/core/ViewChild",target:"_blank",rel:"noopener noreferrer"}},[e._v("@ViewChild"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("Angular 提供了一种称为DOM查询的机制，它以@ViewChild 和 @ViewChildren 装饰器的形式出现。它们行为相同，只是前者返回一个引用，而后者返回多个引用作为"),a("a",{attrs:{href:"https://angular.cn/api/core/QueryList",target:"_blank",rel:"noopener noreferrer"}},[e._v("QueryList"),a("OutboundLink")],1),e._v("(不可修改，当应用状态变化时，Angular会保证它是最新的)")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("@Component({\n    selector: 'sample',\n    template: `\n        <span #tref>I am span</span>\n    `\n})\nexport class SampleComponent implements AfterViewInit {\n    @ViewChild(\"tref\", {read: ElementRef}) tref: ElementRef;\n\n    ngAfterViewInit(): void {\n        // outputs `I am span`\n        console.log(this.tref.nativeElement.textContent);\n    }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br")])]),a("p",[e._v("ViewChild装饰器语法如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("@ViewChild([reference from template], {read: [reference type], static: true | false});\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("并不总是需要读取read，因为 angular 可以通过 DOM 元素的类型推断引用类型。例如，如果是 span 这样的 html 元素，则 angular 返回 ElementRef。如果是模板元素，则返回 TemplateRef。 某些引用，例如 ViewContainerRef 无法推断，必须在读取参数中专门询问。 例如 ViewRef 不能从 DOM 中返回，必须手动构建。")]),e._v(" "),a("p",[e._v("static 如果为 true，则在变更检测之前解析查询结果，如果为 false，则在变更检测之后解析。默认为false。")]),e._v(" "),a("h2",{attrs:{id:"elementref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#elementref"}},[e._v("#")]),e._v(" "),a("a",{attrs:{href:"https://angular.cn/api/core/ElementRef",target:"_blank",rel:"noopener noreferrer"}},[e._v("ElementRef"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("这是最基本的抽象，其中只包含与其关联的原生元素。对于访问原生 DOM 元素非常有用")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// outputs `I am span`\nconsole.log(this.tref.nativeElement.textContent);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("Angular 团队不鼓励这种用法。不仅会带来安全风险，而且还会使得程序和渲染层之间产生紧密耦合，从而难以在多个平台上运行程序。需要直接访问 DOM 时，优先使用 Angular 提供的模板和数据绑定机制。")]),e._v(" "),a("h2",{attrs:{id:"templateref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#templateref"}},[e._v("#")]),e._v(" "),a("a",{attrs:{href:"https://angular.cn/api/core/TemplateRef",target:"_blank",rel:"noopener noreferrer"}},[e._v("TemplateRef"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("表示一个内嵌模板，它可以用于实例化内嵌的视图。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("@Component({\n    selector: 'sample',\n    template: `\n        <template #tpl>\n            <span>I am span in template</span>\n        </template>\n    `\n})\nexport class SampleComponent implements AfterViewInit {\n    @ViewChild(\"tpl\") tpl: TemplateRef<any>;\n\n    ngAfterViewInit() {\n        let elementRef = this.tpl.elementRef;\n        // outputs `template bindings={}`\n        console.log(elementRef.nativeElement.textContent);\n    }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br")])]),a("p",[e._v("框架会从 DOM 中删除模板元素，并在其位置插入注释。这是渲染时的样子：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<sample>\n    \x3c!--template bindings={}--\x3e\n</sample>\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("TemplateRef 类本身是一个简单的类。它在 elementRef 属性中保存对其宿主元素的引用，并有一个方法 createEmbeddedView 可以创建一个视图，并将它的引用作为 ViewRef 返回。")]),e._v(" "),a("h2",{attrs:{id:"viewref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#viewref"}},[e._v("#")]),e._v(" "),a("a",{attrs:{href:"https://angular.cn/api/core/ViewRef",target:"_blank",rel:"noopener noreferrer"}},[e._v("ViewRef"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("这个类型的抽象表示一个 Angular View。在 Angular 中，视图是应用程序 UI 的基本构建块。是创建和销毁的最小元素集合。Angular 鼓励开发人员将 UI 视为视图的组合，而不是独立的 html 标签树。")]),e._v(" "),a("p",[e._v("子类为 "),a("a",{attrs:{href:"https://angular.cn/api/core/EmbeddedViewRef",target:"_blank",rel:"noopener noreferrer"}},[e._v("EmbeddedViewRef"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"viewcontainerref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#viewcontainerref"}},[e._v("#")]),e._v(" "),a("a",{attrs:{href:"https://angular.cn/api/core/ViewContainerRef",target:"_blank",rel:"noopener noreferrer"}},[e._v("ViewContainerRef"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("表示可以将一个或多个视图附着到组件中的容器。")]),e._v(" "),a("p",[e._v("可以包含宿主视图（当用 createComponent() 方法实例化组件时创建）和内嵌视图（当用 createEmbeddedView() 方法实例化 TemplateRef 时创建）。")]),e._v(" "),a("p",[e._v("还可以包含其他视图容器，以创建层次化视图。")]),e._v(" "),a("p",[e._v("任何 DOM 元素都可以用作视图容器，但 Angular 不会在元素内插入视图，而是附加绑定到 ViewContainer 的元素之后。类似 router-outlet 插入组件的方式。通常， 标记应创建 ViewContainer 的位置是 ng-container 元素，它呈现为注释，不会引入多余的 html 元素。以下是示例：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("@Component({\n    selector: 'sample',\n    template: `\n        <span>I am first span</span>\n        <ng-container #vc></ng-container>\n        <span>I am last span</span>\n    `\n})\nexport class SampleComponent implements AfterViewInit {\n    @ViewChild(\"vc\", {read: ViewContainerRef}) vc: ViewContainerRef;\n\n    ngAfterViewInit(): void {\n        // outputs `template bindings={}`\n        console.log(this.vc.element.nativeElement.textContent);\n    }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("p",[e._v("与其他 DOM 抽象一样，ViewContainer 通过元素属性来与实际 DOM 绑定。它绑定到渲染为注释的 ng-container，所以输出是 template bindings={}")]),e._v(" "),a("h2",{attrs:{id:"操作视图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作视图"}},[e._v("#")]),e._v(" 操作视图")]),e._v(" "),a("p",[e._v("ViewContainer 提供了一系列 API 来操作视图：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class ViewContainerRef {\n    ...\n    clear() : void\n    insert(viewRef: ViewRef, index?: number) : ViewRef\n    get(index: number) : ViewRef\n    indexOf(viewRef: ViewRef) : number\n    detach(index?: number) : ViewRef\n    move(viewRef: ViewRef, currentIndex: number) : ViewRef\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("可以通过模板和组件手动创建两个方法来创建视图。有了视图，我们就可以使用 insert 方法将其插入到 DOM 中。以下时从模板创建嵌入视图并将其插入到由 ng-container 元素标记的特定位置的示例：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('@Component({\n    selector: \'sample\',\n    template: `\n        <span>I am first span</span>\n        <ng-container #vc></ng-container>\n        <span>I am last span</span>\n        <template #tpl>\n            <span>I am span in template</span>\n        </template>\n    `\n})\nexport class SampleComponent implements AfterViewInit {\n    @ViewChild("vc", {read: ViewContainerRef}) vc: ViewContainerRef;\n    @ViewChild("tpl") tpl: TemplateRef<any>;\n\n    ngAfterViewInit() {\n        let view = this.tpl.createEmbeddedView(null);\n        this.vc.insert(view);\n    }\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br")])]),a("p",[e._v("生成的 html 如下所示：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<sample>\n    <span>I am first span</span>\n    \x3c!--template bindings={}--\x3e\n    <span>I am span in template</span>\n\n    <span>I am last span</span>\n    \x3c!--template bindings={}--\x3e\n</sample>\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("h2",{attrs:{id:"创建视图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建视图"}},[e._v("#")]),e._v(" 创建视图")]),e._v(" "),a("p",[e._v("ViewContainer 还提供了 API 来自动创建视图：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class ViewContainerRef {\n    element: ElementRef\n    length: number\n\n    createComponent(componentFactory...): ComponentRef<C>\n    createEmbeddedView(templateRef...): EmbeddedViewRef<C>\n    ...\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("这些只是我们在上面手动完成的简单方便的包装器。他们从模板或组件创建视图并插入到指定位置。")]),e._v(" "),a("h3",{attrs:{id:"ngtemplateoutlet-和-ngcomponentoutlet-指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ngtemplateoutlet-和-ngcomponentoutlet-指令"}},[e._v("#")]),e._v(" ngTemplateOutlet 和 ngComponentOutlet 指令")]),e._v(" "),a("p",[a("em",[e._v("ngTemplateOutlet")])]),e._v(" "),a("p",[e._v("这个指令将 DOM 元素标记为 ViewContainer 并在其中插入由模板创建的嵌入式视图，无需在组件类中显式执行此操作。这意味着创建视图并插入 DOM 元素可以这样写：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("@Component({\n    selector: 'sample',\n    template: `\n        <span>I am first span</span>\n        <ng-container [ngTemplateOutlet]=\"tpl\"></ng-container>\n        <span>I am last span</span>\n        <template #tpl>\n            <span>I am span in template</span>\n        </template>\n    `\n})\nexport class SampleComponent {}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br")])]),a("p",[e._v("而无需在组件类中使用任何视图实例化代码。")]),e._v(" "),a("p",[a("em",[e._v("ngComponentOutlet")])]),e._v(" "),a("p",[e._v("该指令与 ngTemplateOutlet 类似，不同之处在于它创建了一个宿主视图（实例化一个组件），而不是一个嵌入式视图。你可以像这样使用它：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<ng-container *ngComponentOutlet="ColorComponent"></ng-container>\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[e._v("Angular 为通过视图操作 DOM 提供了一个清晰的心智模型。可以通过使用 ViewChild 查询和模板变量引用来获取 Angular DOM 抽象的引用。DOM 元素最简单的包装器是 ElementRef。对于模板，可以使用 TemplateRef 来创建嵌入式视图。可以用 COmponentFactoryResolver（实例化组件对象）的 componentRef 上访问宿主视图。可以使用 ViewContainerRef 操作视图。可以用过 ngTemplateOutlet（嵌入式视图）和 ngComponentOutlet（宿主视图/动态组件）来自动化插入视图。")])])}),[],!1,null,null,null);n.default=t.exports}}]);