(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{611:function(e,t,v){"use strict";v.r(t);var s=v(15),_=Object(s.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[v("code",[e._v("<script setup>")]),e._v(" 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。相比于普通的 "),v("code",[e._v("<script>")]),e._v(" 语法，它具有更多优势：")]),e._v(" "),v("ul",[v("li",[e._v("更少的样板内容，更简洁的代码。")]),e._v(" "),v("li",[e._v("能够使用纯 Typescript 声明 props 和抛出事件。")]),e._v(" "),v("li",[e._v("更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。")]),e._v(" "),v("li",[e._v("更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。")])]),e._v(" "),v("blockquote",[v("p",[e._v("这里面的代码会被编译成组件 "),v("code",[e._v("setup()")]),e._v(" 函数的内容，这也就意味着与普通的 "),v("code",[e._v("<script>")]),e._v(" 只在组件被首次引入的时候仅执行一次不同， "),v("code",[e._v("<script setup>")]),e._v(" 会在每次组件示例被创建的时候执行。")])]),e._v(" "),v("p",[v("strong",[e._v("顶层的绑定会被暴露给模板")])]),e._v(" "),v("p",[e._v("当使用"),v("code",[e._v("<script setup>")]),e._v("的时候，任何声明的顶层的绑定（包括变量、函数声明，以及import引入的内容）都能在模板中使用。")]),e._v(" "),v("p",[v("strong",[e._v("使用组件")])]),e._v(" "),v("p",[v("code",[e._v("<script setup>")]),e._v("里引入的组件可以在模板中直接使用，而不用通过components声明。")]),e._v(" "),v("p",[v("strong",[e._v("动态组件")])]),e._v(" "),v("p",[e._v("由于组件被引用为变量而不是作为字符串键来注册的，在"),v("code",[e._v("<script setup>")]),e._v("中要使用动态组件的时候，就应该使用动态的 "),v("code",[e._v(":is")]),e._v(" 来绑定")]),e._v(" "),v("p",[v("strong",[e._v("递归组件")])]),e._v(" "),v("p",[e._v("一个单文件组件可以通过它的文件名被其自己所引用。")]),e._v(" "),v("p",[e._v("这种方式相比于 import 导入的组件优先级更低。如果有命名的 import 导入和组件的推断名冲突了，可以使用 import 别名导入。")]),e._v(" "),v("p",[v("strong",[e._v("命名空间组件")])]),e._v(" "),v("p",[e._v("可以使用带点的组件标记，例如 "),v("code",[e._v("<Foo.Bar>")]),e._v(" 来引用嵌套在对象属性中的组件。这在需要从单个文件中导入多个组件的时候非常有用。")]),e._v(" "),v("p",[v("strong",[e._v("使用自定义指令")])]),e._v(" "),v("p",[e._v("本地注册的指令可以直接在模板中使用，但必须以 "),v("code",[e._v("vNameOfDirective")]),e._v(" 的形式来命名本地自定义指令，以使得它们可以直接在模板中使用。导入的指令同样能工作，且可以通过重命名来使其符合命名规范。")]),e._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("<script setup>\nconst vMyDirective = {\n  beforeMount: (el) => {\n    // 在元素上做些操作\n  }\n}\n<\/script>\n<template>\n  <h1 v-my-directive>This is a Heading</h1>\n</template>\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br"),v("span",{staticClass:"line-number"},[e._v("5")]),v("br"),v("span",{staticClass:"line-number"},[e._v("6")]),v("br"),v("span",{staticClass:"line-number"},[e._v("7")]),v("br"),v("span",{staticClass:"line-number"},[e._v("8")]),v("br"),v("span",{staticClass:"line-number"},[e._v("9")]),v("br"),v("span",{staticClass:"line-number"},[e._v("10")]),v("br")])]),v("p",[v("strong",[v("code",[e._v("defineProps")]),e._v(" 和 "),v("code",[e._v("defineEmits")])])]),e._v(" "),v("p",[e._v("在 "),v("code",[e._v("<script setup>")]),e._v(" 中必须使用 "),v("code",[e._v("defineProps")]),e._v(" 和 "),v("code",[e._v("defineEmits")]),e._v(" API 来声明 props 和 emits ，它们具备完整的类型推断并且在 "),v("code",[e._v("<script setup>")]),e._v(" 中是直接可用的，无需通过 "),v("code",[e._v("import { xxx } from 'vue'")]),e._v(" 引入。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("defineProps")]),e._v(" 接收与 "),v("a",{attrs:{href:"https://v3.cn.vuejs.org/api/options-data.html#props",target:"_blank",rel:"noopener noreferrer"}},[v("code",[e._v("props")]),e._v(" 选项"),v("OutboundLink")],1),e._v("相同的值，"),v("code",[e._v("defineEmits")]),e._v(" 也接收 "),v("a",{attrs:{href:"https://v3.cn.vuejs.org/api/options-data.html#emits",target:"_blank",rel:"noopener noreferrer"}},[v("code",[e._v("emits")]),e._v(" 选项"),v("OutboundLink")],1),e._v("相同的值。")]),e._v(" "),v("li",[e._v("传入到 defineProps 和 defineEmits 的选项会从 setup 中提升到模块的范围。因此，传入的选项不能引用在 setup 范围中声明的局部变量。这样做会引起编译错误。但是，它可以引用导入的绑定，因为它们也在模块范围内。")])]),e._v(" "),v("p",[e._v("如果使用了 Typescript，使用"),v("a",{attrs:{href:"https://v3.cn.vuejs.org/api/sfc-script-setup.html#%E4%BB%85%E9%99%90-typescript-%E7%9A%84%E5%8A%9F%E8%83%BD",target:"_blank",rel:"noopener noreferrer"}},[e._v("纯类型声明来声明 prop 和 emits "),v("OutboundLink")],1),e._v("也是可以的。")]),e._v(" "),v("p",[v("strong",[e._v("defineExpose")])]),e._v(" "),v("p",[e._v("使用 "),v("code",[e._v("<script setup>")]),e._v(" 的组件是默认关闭的，也即通过模板 ref 或者 $parent 链获取到的组件的公开实例，不会暴露任何在"),v("code",[e._v("<script setup>")]),e._v(" 中声明的绑定。")]),e._v(" "),v("p",[e._v("为了在 "),v("code",[e._v("<script setup>")]),e._v(" 组件中明确要暴露出去的属性，使用 "),v("code",[e._v("defineExpose")]),e._v(" 编译器宏(ref 会和在普通实例中一样被自动解包)。")]),e._v(" "),v("p",[v("strong",[v("code",[e._v("useSlots")]),e._v(" 和 "),v("code",[e._v("useAttrs")])])]),e._v(" "),v("p",[e._v("在 "),v("code",[e._v("<script setup>")]),e._v(" 使用 "),v("code",[e._v("slots")]),e._v(" 和 "),v("code",[e._v("attrs")]),e._v(" 的情况应该是很罕见的，因为可以在模板中通过 "),v("code",[e._v("$slots")]),e._v(" 和 "),v("code",[e._v("$attrs")]),e._v(" 来访问它们。在你的确需要使用它们的罕见场景中，可以分别用 "),v("code",[e._v("useSlots")]),e._v(" 和 "),v("code",[e._v("useAttrs")]),e._v(" 两个辅助函数。它会返回与 setupContext.slots 和 setupContext.attrs 等价的值，同样也能在普通的组合式 API 中使用。")]),e._v(" "),v("p",[v("strong",[e._v("与普通的 "),v("code",[e._v("<script>")]),e._v(" 一起使用")])]),e._v(" "),v("p",[v("code",[e._v("<script setup>")]),e._v(" 可以和普通的 "),v("code",[e._v("<script>")]),e._v(" 一起使用。普通的 "),v("code",[e._v("<script>")]),e._v(" 在有这些需要的情况下或许会被使用到：")]),e._v(" "),v("ul",[v("li",[e._v("无法在 "),v("code",[e._v("<script setup>")]),e._v(" 声明的选项，例如 inheritAttrs 或通过插件启用的自定义的选项。")]),e._v(" "),v("li",[e._v("声明命名导出。")]),e._v(" "),v("li",[e._v("运行副作用或者创建只需要执行一次的对象。")])]),e._v(" "),v("p",[e._v("**顶层 "),v("code",[e._v("await")]),e._v(" **\n"),v("code",[e._v("<script setup>")]),e._v(" 中可以使用顶层 await。结果代码会被编译成 "),v("code",[e._v("async setup()")]),e._v("。async setup() 必须与 Suspense 组合使用")])])}),[],!1,null,null,null);t.default=_.exports}}]);