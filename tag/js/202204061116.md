---
title: 闭包
date: 2022-4-6 11:16
tags:
 - js
categories: 
 - js
---

::: tip 介绍
一个函数和对其周围状态<strong>（lexical environment，词法环境）</strong>的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包（closure）</strong>。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。
:::

<!-- more -->

**闭包**

先来考虑一下例子:
```
function makeFunc() {
    var name = "Mozilla";
    function displayName() {
        alert(name);
    }
    return displayName;
}

var myFunc = makeFunc();
myFunc();
```
第一眼看上去，也许不能直观地看出这段代码能够正常运行。在一些编程语言中，一个函数中的局部变量仅存在于此函数的执行期间。一旦`makeFunc()`执行完毕，你可能会认为`name`变量将不能再被访问。然而，因为代码仍按预期运行，所以在JavaScript中情况显然与此不同。

原因在于，JavaScript中的函数会形成闭包。`闭包`是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。在本例子中，`myFunc`是执行`makeFunc`时创建的`displayName`函数实例的引用。`displayName`的实例维持了一个对它的词法环境(变量`name`存在于其中)的引用。因此，当`myFunc`被调用时，变量`name`依然可用，其值`Mozilla`就被传递到`alert`中。

下面是一个更有意思的实例——一个`makeAdder`函数：
```
function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2));  // 7
console.log(add10(2)); // 12
```
在这个示例中，我们定义了`makeAdder(x)`函数，它接受一个参数`x`，并返回一个新的函数。返回的函数接受一个参数`y`，并返回`x+y`的值。

