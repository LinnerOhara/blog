---
title: 微任务、宏任务和Event Loop
date: 2022-4-4
tags:
 - js
categories: 
 - js
---

::: tip 介绍
JavaScript 本质上是一门单线程语言。对于在它被设计出来的那个年代来说，这样的设计是一个很好的选择。那个时候的人们很少有多处理器计算机，并且当时也只是打算用 JavaScript 来编写少量的代码。<br>
随着时间的流逝，电脑的性能得到了飞速的提升。JavaScript 也变成了众多流行语言中的一员。许多非常受欢迎的应用或多或少都有 JavaScript 的影子。为此，找到一种可以突破传统单线程语言限制的方法变得很有必要。
:::

<!-- more -->

**JavaScript执行上下文**

当一段JavaScript代码在运行的时候，它实际上是运行在`执行上下文`中。下面3种类型的代码会创建一个新的执行上下文：
* `全局上下文`(又称`全局作用域`)是为运行代码主体而创建的执行上下文，也就是说它是为那些存在于JavaScript函数之外的任何代码而创建的。
* 每个函数会在执行的时候创建自己的执行上下文。这个上下文就是通常说的`“本地上下文”`/`“函数作用域”`。
* 使用 [eval()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval) 函数也会创建一个新的执行上下文。

每一个上下文在本质上都是一种作用域层级。每个代码段开始执行的时候都会创建一个新的上下文来运行它，并且在代码退出的时候销毁掉。看看下面这段JavaScript程序:
```
function fn1(str) {
  function innerFn1 () {}

  innerFn1();
  console.log(str);
}

fn1('first');
fn1('second');
fn1('third');
```

每个上下文创建的时候会被推入[执行上下文栈](https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack)。当退出的时候，他会从上下文栈中移除。
* 程序开始运行时，全局上下文就会被创建好。
    * 当执行到`fn1('first')`的时候会为`fn1()`函数创建一个它的上下文。这个执行上下文会被推入执行上下文栈中。
        * 当`fn1()`调用`innerFn1()`的时候会为该方法创建一个新的上下文。并且在`innerFn1()`退出的时候它的上下文也会从执行栈中弹出并销毁。程序会从栈中获取下一个上下文并恢复执行，也就是从`fn1()`剩下的部分开始执行。
        * `fn1()`执行完毕并退出。其上下文也从栈中弹出并销毁。
    * 当`fn1('second')`开始执行时，程序又会为他创建一个上下文并推入栈顶。
        * 当 `fn1()` 调用 `innerFn1()`的时候另一个上下文被创建并用于运行该函数。 当 `innerFn1()` 退出的时候它的上下文也从栈中弹出并销毁。 `fn1()` 得到恢复并继续执行剩下的部分。
        *  `fn1()` 执行完毕并退出，其上下文也从栈中弹出并销毁。
    * 然后执行到`fn1('third')` 又再为它创建一个上下文并推入栈顶。
        * 当 `fn1()` 调用 `innerFn1()`的时候，另一个上下文被创建用于执行该函数。当`innerFn1()`执行完毕，它的上下文也从栈中弹出并销毁。
        *  `fn1()` 执行完毕退出，其上下文也从栈中弹出并销毁。
* 主程序退出，全局执行上下文从执行栈中弹出。此时栈中所有的上下文都已经弹出，程序执行完毕。

以这种方式来使用执行上下文，使得每个程序和函数都能拥有自己的变量和其他对象。每个上下文还能够额外的跟踪程序中下一行需要执行的代码以及一些对上下文非常重要的信息。以这种方式来使用上下文和上下文栈，使得我们可以对程序运行的一些基础部分进行管理，包括局部和全局变量、函数的调用和返回等。

关于递归函数——即多次调用自身的函数，需要特别注意：每次递归调用自身都会创建一个新的上下文。这使得JavaScript运行时能够追踪递归的层级以及从递归中得到返回值，但这也意味着每次递归都会消耗内存来创建上下文。所以若是你的递归函数中没有正确的返回值/没有及时中止递归，会使得`执行上下文栈`溢出，从而引发程序崩溃。

尾调用、<strong>闭包</strong>